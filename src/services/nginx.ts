import * as fs from 'fs-extra'
import * as path from 'path'
import { DeploymentConfig } from '../types'
import { logger } from '../utils/logger'
import { requireCommand, runCommand } from '../utils/shell'

export class NginxService {
  private configDir = '/etc/nginx/sites-available'
  private enabledDir = '/etc/nginx/sites-enabled'
  private configFile: string

  constructor(private config: DeploymentConfig, private projectPath: string = process.cwd()) {
    this.configFile = path.join(this.configDir, `${config.project.name}.conf`)
  }

  async ensureInstalled(): Promise<void> {
    await requireCommand(
      'nginx',
      'Install with: sudo apt-get install nginx (Ubuntu/Debian) or sudo yum install nginx (CentOS/RHEL)'
    )
  }

  async generateConfig(): Promise<string> {
    const { project, services } = this.config

    // Separate frontend and backend services
    const frontendServices = services.filter((s) => s.type === 'frontend')
    const backendServices = services.filter((s) => s.type === 'backend' || s.type === 'service')

    let nginxConfig = `# Auto-generated by Nimman
# Project: ${project.name}
# Domain: ${project.domain}

# Upstream definitions for backend services
`

    // Create upstream blocks for backend services
    backendServices.forEach((service) => {
      nginxConfig += `upstream ${service.name} {
    least_conn;
    server 127.0.0.1:${service.port};
    keepalive 32;
}

`
    })

    // Main server block
    nginxConfig += `server {
    listen 80;
    server_name ${project.domain} www.${project.domain};

    # Redirect to HTTPS (will be enabled after SSL setup)
    # return 301 https://$server_name$request_uri;

    # For initial setup, serve HTTP
    client_max_body_size 10M;

    # Gzip compression
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss;

`

    // Frontend service (static files or SPA)
    if (frontendServices.length > 0) {
      const frontend = frontendServices[0]
      const frontendPath = frontend.build?.output || 'dist'

      nginxConfig += `    # Frontend
    root ${path.resolve(this.projectPath, frontend.path, frontendPath)};
    index index.html;

    location / {
        try_files $uri $uri/ /index.html;
    }

`
    }

    // Backend API routes
    backendServices.forEach((service) => {
      const apiPath =
        service.name === 'api' || service.name === 'backend' ? '/api' : `/${service.name}`
      nginxConfig += `    # ${service.name} service
    location ${apiPath} {
        proxy_pass http://${service.name};
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 300s;
        proxy_connect_timeout 75s;
    }

`
    })

    // Health check endpoint
    nginxConfig += `    # Health check
    location /health {
        access_log off;
        return 200 "healthy\\n";
        add_header Content-Type text/plain;
    }
}

`

    // HTTPS server block (commented out initially)
    nginxConfig += `# HTTPS server block (uncomment after SSL setup)
# server {
#     listen 443 ssl http2;
#     server_name ${project.domain} www.${project.domain};
#
#     ssl_certificate /etc/letsencrypt/live/${project.domain}/fullchain.pem;
#     ssl_certificate_key /etc/letsencrypt/live/${project.domain}/privkey.pem;
#     ssl_protocols TLSv1.2 TLSv1.3;
#     ssl_ciphers HIGH:!aNULL:!MD5;
#     ssl_prefer_server_ciphers on;
#
#     client_max_body_size 10M;
#
#     gzip on;
#     gzip_vary on;
#     gzip_min_length 1024;
#     gzip_types text/plain text/css text/xml text/javascript application/json application/javascript application/xml+rss;
#
`

    if (frontendServices.length > 0) {
      const frontend = frontendServices[0]
      const frontendPath = frontend.build?.output || 'dist'
      nginxConfig += `#     root ${path.resolve(this.projectPath, frontend.path, frontendPath)};
#     index index.html;
#
#     location / {
#         try_files $uri $uri/ /index.html;
#     }
#
`
    }

    backendServices.forEach((service) => {
      const apiPath =
        service.name === 'api' || service.name === 'backend' ? '/api' : `/${service.name}`
      nginxConfig += `#     location ${apiPath} {
#         proxy_pass http://${service.name};
#         proxy_http_version 1.1;
#         proxy_set_header Upgrade $http_upgrade;
#         proxy_set_header Connection 'upgrade';
#         proxy_set_header Host $host;
#         proxy_set_header X-Real-IP $remote_addr;
#         proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
#         proxy_set_header X-Forwarded-Proto $scheme;
#         proxy_cache_bypass $http_upgrade;
#     }
#
`
    })

    nginxConfig += `# }
`

    return nginxConfig
  }

  async setup(): Promise<void> {
    await this.ensureInstalled()

    logger.step('Generating Nginx configuration...')
    const config = await this.generateConfig()

    // Check if running as root (required for nginx config)
    const { stdout: whoami } = await runCommand('whoami', [], { silent: true })
    const isRoot = whoami.trim() === 'root'

    if (!isRoot) {
      logger.warn('Nginx configuration requires root privileges')
      logger.step(
        'Writing config to current directory (copy to /etc/nginx/sites-available manually)'
      )
      await fs.writeFile(`${this.config.project.name}.nginx.conf`, config, 'utf-8')
      logger.success(`Config written to ${this.config.project.name}.nginx.conf`)
      logger.info(
        'To apply: sudo cp this file to /etc/nginx/sites-available/ and run: sudo nginx -t && sudo systemctl reload nginx'
      )
      return
    }

    // Write config file
    await fs.writeFile(this.configFile, config, 'utf-8')
    logger.success(`Nginx config written to ${this.configFile}`)

    // Create symlink to enabled
    const enabledLink = path.join(this.enabledDir, path.basename(this.configFile))
    if (await fs.pathExists(enabledLink)) {
      await fs.remove(enabledLink)
    }
    await fs.ensureSymlink(this.configFile, enabledLink)
    logger.success(`Symlink created: ${enabledLink}`)

    // Test nginx config
    logger.step('Testing Nginx configuration...')
    await runCommand('nginx', ['-t'])

    // Reload nginx
    logger.step('Reloading Nginx...')
    await runCommand('systemctl', ['reload', 'nginx'])
    logger.success('Nginx configured and reloaded')
  }

  async enableHTTPS(): Promise<void> {
    await this.ensureInstalled()

    logger.step('Enabling HTTPS in Nginx config...')
    const config = await this.generateConfig()

    // Uncomment HTTPS block and redirect
    let updatedConfig = config
      .replace(
        '# return 301 https://$server_name$request_uri;',
        'return 301 https://$server_name$request_uri;'
      )
      .replace(/# server \{[\s\S]*?# \}/, (match) => match.replace(/# /g, ''))

    const { stdout: whoami } = await runCommand('whoami', [], { silent: true })
    const isRoot = whoami.trim() === 'root'

    if (!isRoot) {
      await fs.writeFile(`${this.config.project.name}.nginx.conf`, updatedConfig, 'utf-8')
      logger.warn('HTTPS config written to current directory. Apply manually with sudo.')
      return
    }

    await fs.writeFile(this.configFile, updatedConfig, 'utf-8')
    await runCommand('nginx', ['-t'])
    await runCommand('systemctl', ['reload', 'nginx'])
    logger.success('HTTPS enabled in Nginx')
  }
}
